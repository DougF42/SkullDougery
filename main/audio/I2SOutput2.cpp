/**
 * I2SOutput2.cpp
 *
 *  Created on: Oct 24, 2022
 *      Author: doug
 *
 */
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <driver/i2s_std.h>
#include <driver/gpio.h>
#include "I2SOutput2.h"
#include "esp_check.h"
#include "../config.h"
static const char *TAG="***I2SOUPUT:";

// Data is stereo, 16-bit so...
//  secs = 2048/(16*2) = 64 frames./
// How big is our buffer?
#define EXAMPLE_BUFF_SIZE               2048

static i2s_chan_handle_t                tx_chan;        // I2S tx channel handler
//static i2s_chan_handle_t                rx_chan;        // I2S rx channel handler



// Single controler ('simplex'). We write sound data, but dont care about receiving it.
//
//
//
I2SOutput2::I2SOutput2 ()
{
	/* Setp 1: Determine the I2S channel configuration and allocate both channels
	 * The default configuration can be generated by the helper macro,
	 * it only requires the I2S controller id and I2S role
	 * (We do NOT specify the read channel)
	 *   */
	i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);
	ESP_ERROR_CHECK(i2s_new_channel (&chan_cfg, &tx_chan, nullptr ) );

	/* Step 2: Setting the configurations of standard mode, and initialize rx & tx channels
	 * The slot configuration and clock configuration can be generated by the macros
	 * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
	 * They can help to specify the slot and clock configurations for initialization or re-configuring
	 */
	i2s_std_config_t std_cfg = {
			.clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(8000),
			.slot_cfg =	I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO),
			.gpio_cfg =
			{ .mclk = I2S_GPIO_UNUSED, // some codecs may require mclk signal, this example doesn't need it
					.bclk = I2S_SPEAKER_SERIAL_CLOCK,
					.ws = I2S_SPEAKER_LEFT_RIGHT_CLOCK,
					.dout =	I2S_SPEAKER_SERIAL_DATA,
					.din =	I2S_GPIO_UNUSED, // In duplex mode, bind output and input to a same gpio can loopback internally
					.invert_flags =
					{ .mclk_inv = false,
							.bclk_inv = false,
							.ws_inv   = false, },
			}
	};

	/* Initialize the channels */
	ESP_ERROR_CHECK(i2s_channel_init_std_mode (tx_chan, &std_cfg ) );
	// RECEIVE MODE NOT USED!!!      ESP_ERROR_CHECK(i2s_channel_init_std_mode(rx_chan, &std_cfg));
}

I2SOutput2::~I2SOutput2()
{

}

void I2SOutput2::start(int sample_rate)
{


}


void I2SOutput2::stop()
{

}


/*
 * Write pwm bytes to the I2C channel. This is a
 * 'blocking' write - it waits until all bytes are in
 * the i2c buffer.
 */
void I2SOutput2::write(int16_t *samples, int bytes_in_buffer)
{
	    size_t w_bytes_written = 0;
	    size_t w_next_byte=0;

	    while (w_next_byte < bytes_in_buffer) {
	        /* Write i2s data */
	        if (i2s_channel_write(tx_chan, samples+w_next_byte, bytes_in_buffer-w_next_byte, &w_bytes_written, 1000) == ESP_OK) {
	            ESP_LOGD(TAG, "Write Task: i2s write %d bytes\n", w_bytes_written);
	            w_next_byte += w_bytes_written;
	        } else {
	            ESP_LOGE(TAG,"Write Task: i2s write failed\n");
	        }
	        vTaskDelay(pdMS_TO_TICKS(200));
	    }
}

//
void I2SOutput2::set_volume(float volume)
{
	return; // NOP in this implementation
}

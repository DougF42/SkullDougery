/**
 * I2SOutput2.cpp
 *
 *  Created on: Oct 24, 2022
 *      Author: doug
 *
 */
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_timer.h"
#include <driver/i2s_std.h>
#include <driver/gpio.h>
#include "I2SOutput2.h"
#include "esp_check.h"
#include "../config.h"
static const char *TAG="***I2SOUPUT:";

// Data is stereo, 16-bit so...
//  secs = 2048/(16*2) = 64 frames./
// How big is our buffer?
#define EXAMPLE_BUFF_SIZE               2048

static i2s_chan_handle_t                tx_chan;        // I2S tx channel handler
//static i2s_chan_handle_t                rx_chan;        // I2S rx channel handler



// Single controler ('simplex'). We write sound data, but dont care
//    about receiving any.
//
//
//
I2SOutput2::I2SOutput2 (uint32_t rate, i2s_data_bit_width_t bits_per_sample)
{
	/* Setp 1: Determine the I2S channel configuration and allocate both channels
	 * The default configuration can be generated by the helper macro,
	 * it only requires the I2S controller id and I2S role
	 * (We do NOT specify the read channel)
	 *   */
	i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);
	ESP_ERROR_CHECK(i2s_new_channel (&chan_cfg, &tx_chan, nullptr ) );

	/* Step 2: Setting the configurations of standard mode, and initialize rx & tx channels
	 * The slot configuration and clock configuration can be generated by the macros
	 * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
	 * They can help to specify the slot and clock configurations for initialization or re-configuring
	 */
	i2s_std_config_t std_cfg;

	std_cfg.clk_cfg.sample_rate_hz = 8000;
	std_cfg.clk_cfg.clk_src = I2S_CLK_SRC_DEFAULT; // default pll clock
	std_cfg.clk_cfg.mclk_multiple = I2S_MCLK_MULTIPLE_256;

	//   std_cfg.slot_cfg
	std_cfg.slot_cfg.data_bit_width = bits_per_sample;
	std_cfg.slot_cfg.slot_bit_width = I2S_SLOT_BIT_WIDTH_16BIT;
	std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_STEREO;
	std_cfg.slot_cfg.ws_width = bits_per_sample;
	std_cfg.slot_cfg.ws_pol = false;
	std_cfg.slot_cfg.bit_shift = false;
	std_cfg.slot_cfg.msb_right = true;

	// GPIO config
	// (some codecs may require mclk signal, this example doesn't need it)
	std_cfg.gpio_cfg.mclk = I2S_GPIO_UNUSED;
	std_cfg.gpio_cfg.bclk = I2S_SPEAKER_SERIAL_CLOCK;
	std_cfg.gpio_cfg.ws   = I2S_SPEAKER_LEFT_RIGHT_CLOCK;
	std_cfg.gpio_cfg.dout =	I2S_SPEAKER_SERIAL_DATA;
	std_cfg.gpio_cfg.din  =	I2S_GPIO_UNUSED;
	std_cfg.gpio_cfg.invert_flags.mclk_inv = false;
	std_cfg.gpio_cfg.invert_flags.bclk_inv = false;
	std_cfg.gpio_cfg.invert_flags.ws_inv   = false;

	/* Initialize the channels */
	ESP_ERROR_CHECK(i2s_channel_init_std_mode (tx_chan, &std_cfg ) );
	// RECEIVE MODE NOT USED!!!      ESP_ERROR_CHECK(i2s_channel_init_std_mode(rx_chan, &std_cfg));
}

/**
 *
 */
I2SOutput2::~I2SOutput2()
{
	stop();
}

void I2SOutput2::start(int sample_rate)
{
	i2s_channel_enable(tx_chan);

}


void I2SOutput2::stop()
{
	i2s_channel_disable(tx_chan);
}


/*
 * Write pwm bytes to the I2C channel. This is a
 * 'blocking' write - it waits until all bytes are in
 * the i2c buffer.
 * @param samples - Ptr to our sample set.
 * @param bytes_in_buffer - number of BYTES in the buffer.
 */
void I2SOutput2::write(const void *samples, int bytes_in_buffer)
{
	    size_t w_bytes_written = 0;
	    size_t w_next_byte=0;
	//    int64_t startTime;
	//    int64_t endTime;
	    while (w_next_byte < bytes_in_buffer) {
	        /* Write i2s data */
	    	//startTime=esp_timer_get_time();
	        if (i2s_channel_write(tx_chan, ((char *)samples)+w_next_byte, bytes_in_buffer-w_next_byte,
	        		&w_bytes_written, 1000) == ESP_OK) {
	        //	endTime=esp_timer_get_time();
	        //  ESP_LOGI(TAG, "Write Task: i2s write %d bytes of %d. delay=%lld\n", w_bytes_written, bytes_in_buffer, endTime-startTime);
	            w_next_byte += w_bytes_written;
	        } else {
	            ESP_LOGE(TAG,"Write Task: i2s write failed\n");
	        }
	    }
}

//
void I2SOutput2::set_volume(float volume)
{
	return; // NOP in this implementation
}
